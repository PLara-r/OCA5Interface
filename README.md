# OCA5Interface

Создание абстрактных классов

Допустим, вы хотите определить родительский класс, который другие разработчики собираются подклассировать. 
Ваша цель - предоставить разработчикам в родительском классе некоторые повторно используемые переменные и методы, 
тогда как разработчики предоставляют конкретные реализации или переопределения других методов в дочерних классах.
Кроме того, допустим, вы также не хотите, чтобы экземпляр родительского класса создавался, если только он не является экземпляром дочернего класса.
Например, вы можете определить Animalродительский класс, из которого расширяется и используется ряд классов,
но экземпляр которого Animalсам по себе не может быть создан. Все подклассы Animalкласса, такие как Swan, необходимы для реализации getName()метода,
но в родительском Animalклассе нет реализации для метода . Как вы гарантируете, что все расширяющиеся классы Animalобеспечивают реализацию для этого метода?
В Java вы можете выполнить эту задачу, используя абстрактный класс и абстрактный метод. Абстрактный класс является классом,
помечается abstractключевым словом и не может быть реализован. Абстрактный метод является методом , помеченным с abstractключевым словом ,
определенным в абстрактном классе, для реализации которой не предусмотрена в классе , в котором он объявлен.

Правила определения абстрактного класса:
1.	Абстрактные классы не могут быть созданы напрямую.
2.	Абстрактные классы могут быть определены с любым числом, включая ноль, абстрактных и неабстрактных методов.
3.	Абстрактные классы не могут быть помечены как privateили final.
4.	Абстрактный класс, который extendsдругой абстрактный класс наследует все свои абстрактные методы как свои собственные абстрактные методы.
5.	Первый конкретный класс, который extendsабстрактный класс должен обеспечивать реализацию для всех унаследованных абстрактных методов.
Правила определения абстрактного метода:
1.	Абстрактные методы могут быть определены только в абстрактных классах.
2.	Абстрактные методы не могут быть объявлены privateили final.
3.	Абстрактные методы не должны предоставлять тело / реализацию метода в абстрактном классе, для которого он объявлен.
4.	Реализация абстрактного метода в подклассе следует тем же правилам для переопределения метода. Например, имя и подпись должны быть одинаковыми,
а видимость метода в подклассе должна быть как минимум такой же доступной, как метод в родительском классе.

Абстрактные классы

Теперь мы переходим к рассмотрению abstractклассов и методов. Какими тремя способами можно заполнить пробел, чтобы этот код компилировался? 
Попытайтесь придумать способы использования этого clean()метода, а не просто оставлять там комментарии.
abstract class Cat {  
 _____________________
}class Lion extends Cat { 
  void clean() {}
}
Вы получили три? Один из них немного хитрый. Хитрость в том, что вы можете оставить это поле пустым. abstractКласс не должен иметь каких - либо методов в нем,
не говоря уже о каких - либо из abstractних. Второй ответ - тот, о котором вы, вероятно, подумали сразу:

abstract void clean();

Это фактический abstractметод. У него есть abstractключевое слово и точка с запятой вместо тела метода. Третий ответ - реализация по умолчанию:

void clean () {}

abstractКласс может содержать любое количество методов , включая нуль. Методы могут быть abstractили конкретными.
Abstractметоды могут не появляться в классе, которого нет abstract. Первый конкретный подкласс abstractкласса требуется для реализации всех abstractметодов,
которые не были реализованы суперклассом.
Обратите внимание, что мы сказали три способа. Есть много других способов. Например, вы можете использовать clean()метод throw a RuntimeException. 


Реализация интерфейсов


Хотя Java не допускает множественного наследования, она позволяет классам реализовывать любое количество интерфейсов.
Интерфейс представляет собой абстрактный тип данных , который определяет список абстрактных общих методов , что любой класс ,
реализующий интерфейс должен обеспечить. Интерфейс также может включать список постоянных переменных и методов по умолчанию,
которые мы рассмотрим в этом разделе. В Java интерфейс определяется с interfaceключевым словом, аналогичным classключевому слову, используемому при определении класса.
Класс вызывает интерфейс, используя implementsключевое слово в определении класса. Обратитесь к рисункам 5.4 и 5.5 для правильного использования синтаксиса.
Рисунок 5.4 Определение интерфейса
Рисунок 5.5 Реализация интерфейса
Как вы видите в этом примере, интерфейс не объявляется абстрактным классом, хотя он обладает многими такими же свойствами абстрактного класса.
Обратите внимание, что в этом примере используются модификаторы метода abstractи public. Другими словами, независимо от того, предоставляете вы их или нет, 
компилятор автоматически вставит их как часть определения метода.
Класс может реализовывать несколько интерфейсов, каждый из которых разделен запятой, например, в следующем примере:
public class Elephant implements WalksOnFourLegs, HasTrunk, Herbivore {}

В примере, если какой-либо из интерфейсов определил абстрактные методы, конкретный класс Elephantпотребовался бы для реализации этих методов.
Новым в Java 8 является понятие стандартных и статических методов интерфейса, которые мы рассмотрим в конце этого раздела.

Определение интерфейса


Может быть полезно думать об интерфейсе как о специализированном виде абстрактного класса, поскольку он разделяет многие из тех же свойств и правил,
что и абстрактный класс. Ниже приведен список правил для создания интерфейса, многие из которых вы должны признать в качестве адаптаций
правил для определения абстрактных классов.
1.	Интерфейсы не могут быть созданы напрямую.
2.	Интерфейс не обязан иметь какие-либо методы.
3.	Интерфейс не может быть помечен как final.
4.	Предполагается, что все интерфейсы верхнего уровня имеют publicдоступ по умолчанию или имеют доступ, и они должны включать abstractмодификатор в свое определение. 
Поэтому, маркировка интерфейса как private, protectedили finalвызовет ошибку компиляции, поскольку это несовместимо с этими предположениями.
5.	Предполагается, что все методы по умолчанию в интерфейсе имеют модификаторы abstractи publicв их определении. 
Таким образом, маркировка метода , как private, protectedили finalвызовет компилятор ошибку , поскольку они несовместимы с abstractи publicключевыми словами.
Четвертое правило не применяется к внутренним интерфейсам, хотя внутренние классы и интерфейсы не входят в сферу применения экзамена ОСА.
Первые три правила идентичны первым трем правилам создания абстрактного класса. Представьте, что у нас есть интерфейс WalksOnTwoLegs, определенный следующим образом:
public interface WalksOnTwoLegs {}

Компилируется без проблем, поскольку интерфейсы не обязаны определять какие-либо методы. Теперь рассмотрим следующие два примера, которые не компилируются:
public class TestClass {  
public static void main(String[] args) {   
 WalksOnTwoLegs example = new WalksOnTwoLegs();  // DOES NOT COMPILE  
}}
public final interface WalksOnEightLegs {  // DOES NOT COMPILE
}
Первый пример не компилируется, так как WalksOnTwoLegsявляется интерфейсом и не может быть создан непосредственно.
Второй пример, WalksOnEightLegsне компилируется, так как интерфейсы не могут быть помечены как finalпо той же причине,
по которой abstractклассы не могут быть помечены как final.
Четвертое и пятое правило о «предполагаемых ключевых словах» может быть новым для вас, но вы должны думать об этом в том же свете,
что и компилятор, вставляющий конструктор или аргумент по умолчанию без аргументов super()в ваш конструктор. Вы можете предоставить эти модификаторы самостоятельно, 
хотя компилятор вставит их автоматически, если вы этого не сделаете. Например, следующие два определения интерфейса эквивалентны, 
так как компилятор преобразует их оба во второй пример:

public interface CanFly { 
 void fly(int speed); 
 abstract void takeoff(); 
 public abstract double dive();
}
public abstract interface CanFly { 
 public abstract void fly(int speed); 
 public abstract void takeoff(); 
 public abstract double dive();
}

В этом примере abstractключевое слово сначала автоматически добавляется в определение интерфейса. Затем каждый метод предваряется abstractи publicключевые слова.
Если метод уже имеет одно из этих ключевых слов, то никаких изменений не требуется. Давайте посмотрим на пример, который нарушает предполагаемые ключевые слова:

private final interface CanCrawl {  // DOES NOT COMPILE 
 private void dig(int depth);  // DOES NOT COMPILE 
 protected abstract double depth();  // DOES NOT COMPILE 
 public final void surface();  // DOES NOT COMPILE
}

Каждая строка этого примера не компилируется. Первая строка не компилируется по двум причинам. Во-первых, он помечен как final, который нельзя применить к интерфейсу, 
поскольку он конфликтует с предполагаемым abstractключевым словом. Далее он помечается как private, что противоречит publicтребуемому или необходимому
по умолчанию доступу для интерфейсов. Вторая и третья строка не компилируются, потому что предполагается, что все методы интерфейса являются publicи
помечают их как privateили protectedвыдают ошибку компилятора. Наконец, последняя строка не компилируется, потому что метод помечен как finalи,
поскольку предполагается abstract, что методы интерфейса являются , компилятор выдает исключение для использования abstractи finalметода, и ключевых слов в методе.
Добавление предполагаемых ключевых слов в интерфейс - вопрос личных предпочтений, хотя это считается хорошей практикой кодирования.
Код с выписанными предполагаемыми ключевыми словами имеет тенденцию быть легче и понятнее для чтения и приводит к меньшему количеству потенциальных конфликтов, 
как вы видели в предыдущих примерах.
Обязательно ознакомьтесь с предыдущим примером и поймите, почему каждая из строк не компилируется. Скорее всего, на экзамене будет хотя бы один вопрос,
в котором интерфейс или метод интерфейса используют недопустимый модификатор.

Наследование интерфейса


При расширении интерфейса следует помнить о двух правилах наследования:
1.	Интерфейс, который является extendsдругим интерфейсом, а также абстрактный класс, который implementsявляется интерфейсом,
наследует все абстрактные методы как свои собственные абстрактные методы.
2.	Первый конкретный класс, который implementsявляется интерфейсом, или extendsабстрактный класс, который implementsявляется интерфейсом,
должен обеспечивать реализацию для всех унаследованных абстрактных методов.
Как и абстрактный класс, интерфейс может быть расширен с помощью extendключевого слова. Таким образом, новый дочерний интерфейс наследует все
абстрактные методы родительского интерфейса. В отличие от абстрактного класса, интерфейс может расширять несколько интерфейсов. Рассмотрим следующий пример:

public interface HasTail {  
public int getTailLength();
}
public interface HasWhiskers {  
public int getNumberOfWhiskers();
}
public interface Seal extends HasTail, HasWhiskers {}
Любой класс, который реализует Sealинтерфейс, должен обеспечивать реализацию для всех методов в родительских интерфейсах -
в этом случае getTailLength()и getNumberOfWhiskers().
Как насчет абстрактного класса, который реализует интерфейс? В этом сценарии абстрактный класс обрабатывается так же, как интерфейс,
расширяющий другой интерфейс. Другими словами, абстрактный класс наследует абстрактные методы интерфейса, но не обязателен для их реализации.
Тем не менее, как и абстрактный класс, первый конкретный класс, расширяющий абстрактный класс, должен реализовать все унаследованные абстрактные методы интерфейса.
Мы проиллюстрируем это на следующем примере:

public interface HasTail {  
public int getTailLength();
}
public interface HasWhiskers {  
public int getNumberOfWhiskers();
}
public abstract class HarborSeal implements HasTail, HasWhiskers {}
public class LeopardSeal implements HasTail, HasWhiskers {  // DOES NOT COMPILE
}
В этом примере мы видим, что HarborSealэто абстрактный класс и компилируется без проблем. Любой класс, extends HarborSealкоторый 
потребуется для реализации всех методов в интерфейсе HasTailand HasWhiskers. Альтернативно, LeopardSealэто не абстрактный класс,
поэтому он должен реализовывать все методы интерфейса в своем определении. В этом примере LeopardSealне предоставляется реализация методов интерфейса,
поэтому код не компилируется.

Классы, интерфейсы и ключевые слова


Создатели экзаменов любят вопросы, которые смешивают терминологию классов и интерфейсов. Хотя класс может реализовывать интерфейс,
класс не может расширять интерфейс. Аналогично, хотя интерфейс может расширять другой интерфейс, интерфейс не может реализовывать другой интерфейс. 
Следующие примеры иллюстрируют эти принципы:

public interface CanRun {}
public class Cheetah extends CanRun {}  // DOES NOT COMPILE
public class Hyena {}
public interface HasFur extends Hyena {} // DOES NOT COMPILE

В первом примере показан класс, пытающийся расширить интерфейс, который не компилируется.
Второй пример показывает интерфейс, пытающийся расширить класс, который также не компилируется.Будьте осторожны с примерами на экзамене,
которые смешивают определения классов и интерфейсов. Убедитесь, что единственное соединение между классом и интерфейсом имеет синтаксис интерфейса класса  .implements 


Абстрактные методы и множественное наследование


Поскольку Java допускает множественное наследование через интерфейсы, вам может быть интересно, что произойдет, если вы определите класс, 
который наследует от двух интерфейсов, содержащих один и тот же abstractметод:

public interface Herbivore {  
public void eatPlants();
}
public interface Omnivore {
  public void eatPlants();  
public void eatMeat();
}
В этом сценарии подписи для двух методов интерфейса eatPlants()совместимы, поэтому вы можете определить класс, который одновременно выполняет оба интерфейса:

public class Bear implements Herbivore, Omnivore { 
 public void eatMeat() {   
 System.out.println("Eating meat"); 
 } 
 public void eatPlants() { 
   System.out.println("Eating plants"); 
 }}
Почему это работает? Помните, что методы интерфейса в этом примере есть abstractи определяют «поведение», которое должен иметь класс, реализующий интерфейс.
Если два abstractинтерфейсных метода имеют идентичное поведение - или в этом случае одну и ту же сигнатуру метода - создание класса, реализующего один из двух методов,
автоматически реализует второй метод. Таким образом, методы интерфейса считаются дубликатами, поскольку они имеют одинаковую подпись.
Что произойдет, если два метода имеют разные подписи? Если имя метода одно и то же, но входные параметры отличаются, конфликт отсутствует,
поскольку это считается перегрузкой метода. Мы продемонстрируем этот принцип в следующем примере:

public interface Herbivore { 
 public int eatPlants(int quantity);
}
public interface Omnivore { 
 public void eatPlants();
}
public class Bear implements Herbivore, Omnivore {  
public int eatPlants(int quantity) {    
System.out.println("Eating plants: "+quantity);  
  return quantity; 
 }
  public void eatPlants() {  
  System.out.println("Eating plants");  
}}
В этом примере мы видим, что класс, реализующий оба интерфейса, должен предоставлять реализации обеих версий eatPlants(), поскольку они рассматриваются как отдельные методы. 
Обратите внимание, что не имеет значения, является ли возвращаемый тип двух методов одинаковым или разным, потому что компилятор обрабатывает эти методы как независимые.
К сожалению, если имя метода и входные параметры совпадают, но возвращаемые типы различаются для двух методов, класс или интерфейс, пытающийся наследовать оба интерфейса,
не скомпилируется. Причина, по которой код не компилируется, связана не столько с интерфейсами, сколько с дизайном классов, как обсуждалось в главе 4.
В Java невозможно определить два метода в классе с одинаковыми именами и входными параметрами, но разными возвращаемые типы.
Учитывая следующие два определения интерфейса для Herbivoreи Omnivore, следующий код не будет компилироваться:


public interface Herbivore {  
public int eatPlants();
}
public interface Omnivore { 
 public void eatPlants();
}
public class Bear implements Herbivore, Omnivore { 
 public int eatPlants() {  // DOES NOT COMPILE  
  System.out.println("Eating plants: 10");   
 return 10; 
 }  
public void eatPlants() {  // DOES NOT COMPILE    
System.out.println("Eating plants");  
}}
Код не компилируется, так как класс определяет два метода с одинаковыми именами и входными параметрами, но разными типами возвращаемых данных.
Если бы мы удалили любое из определений eatPlants(), компилятор остановился бы, потому что в определении Bearотсутствовал бы один из обязательных методов. 
Другими словами, нет реализации Bearкласса, который наследуется Herbivoreи Omnivoreкоторый компилятор примет.
Компилятор также сгенерирует исключение, если вы определите интерфейс или abstractкласс, который наследуется от двух конфликтующих интерфейсов, как показано здесь:

public interface Herbivore {  
public int eatPlants();
}
public interface Omnivore { 
public void eatPlants();
}
public interface Supervore extends Herbivore, Omnivore {} // DOES NOT COMPILE
public abstract class AbstractBear implements Herbivore, Omnivore {}         
                                        // DOES NOT COMPILE


Даже без подробностей реализации компилятор обнаруживает проблему с abstractопределением и предотвращает компиляцию.
На этом мы завершаем обсуждение abstractметодов интерфейса и множественного наследования. Мы вернемся к этому обсуждению вскоре после того,
как представим стандартные методы интерфейса. Вы увидите, что с методами интерфейса по умолчанию все работает немного иначе.

Переменные интерфейса


Давайте расширим наше обсуждение интерфейсов, чтобы включить переменные интерфейса, которые могут быть определены в интерфейсе. Как и методы интерфейса,
переменные интерфейса считаются public. Однако, в отличие от методов интерфейса, переменные интерфейса также считаются staticи final.
Вот два правила интерфейсных переменных:
1.	Переменные интерфейса считаются public, staticи final. Следовательно, пометка переменной как privateили protectedвызовет ошибку компилятора, 
как и любая переменная как abstract.
2.	Значение интерфейсной переменной должно быть установлено, когда оно объявлено, поскольку оно помечено как final.
Таким образом, переменные интерфейса по существу являются постоянными переменными, определенными на уровне интерфейса. Поскольку они предполагаются static,
они доступны даже без экземпляра интерфейса. Как и в нашем предыдущем CanFlyпримере, следующие два определения интерфейса эквивалентны,
поскольку компилятор автоматически преобразует их оба во второй пример:

public interface CanSwim { 
 int MAXIMUM_DEPTH = 100; 
 final static boolean UNDERWATER = true; 
 public static final String TYPE = "Submersible";
}
public interface CanSwim { 
 public static final int MAXIMUM_DEPTH = 100; 
 public static final boolean UNDERWATER = true; 
 public static final String TYPE = "Submersible";
}
Как мы видим в этом примере, компиляция будет автоматически вставляться public static finalв любые постоянные переменные интерфейса,
которые будут сочтены отсутствующими в этих модификаторах. Также обратите внимание, что распространенной практикой кодирования является
использование заглавных букв для обозначения постоянных значений в классе.
Исходя из этих правил, неудивительно, что следующие записи не будут компилироваться:

public interface CanDig { 
 private int MAXIMUM_DEPTH = 100;  // DOES NOT COMPILE 
 protected abstract boolean UNDERWATER = false;  // DOES NOT COMPILE 
 public static String TYPE;  // DOES NOT COMPILE
}
Первый пример, MAXIMUM_DEPTHне компилируется, потому что используется privateмодификатор, и предполагается, что все переменные интерфейса public.
Вторая строка UNDERWATERне компилируется по двум причинам. Он помечен как protected, что противоречит предполагаемому модификатору public, и помечен как abstract, 
что противоречит предполагаемому модификатору final. Наконец, последний пример TYPEне компилируется, потому что в нем отсутствует значение.
В отличие от других примеров, модификаторы верны, но, как вы помните из главы 4, вы должны предоставить значение static finalчлену класса, когда оно определено.

Методы интерфейса по умолчанию


С выпуском Java 8 авторы Java представили новый тип метода для интерфейса, называемый методом по умолчанию. Способ по умолчанию является методом ,
определенным в пределах интерфейса с defaultключевым словом , в котором предусмотрено способе тело. Сравните методы по умолчанию с «обычными» методами в интерфейсе,
которые считаются абстрактными и могут не иметь тела метода.
Метод по умолчанию в интерфейсе определяет абстрактный метод с реализацией по умолчанию. Таким образом, классы имеют возможность переопределить метод по умолчанию,
если это необходимо, но они не обязаны это делать. Если класс не переопределяет метод, будет использоваться реализация по умолчанию.
Таким образом, определение метода является конкретным, а не абстрактным.
Целью добавления методов по умолчанию к языку Java было частично помочь в разработке кода и обратной совместимости. Представьте,
что у вас есть интерфейс, которым пользуются десятки или даже сотни пользователей, к которым вы хотите добавить новый метод.
Если вы просто обновите интерфейс новым методом, реализация будет нарушена среди всех ваших подписчиков, которые затем будут вынуждены обновить свой код.
На практике это может даже отговорить вас от внесения изменений в целом. Однако, предоставляя реализацию метода по умолчанию,
интерфейс становится обратно совместимым с существующей кодовой базой, в то же время предоставляя тем лицам, которые хотят использовать новый метод,
возможность переопределить его.
Ниже приведен пример метода по умолчанию, определенного в интерфейсе:

public interface IsWarmBlooded {
  boolean hasScales(); 
 public default double getTemperature() {  
  return 10.0;
  }}
В этом примере определяются два метода интерфейса: один является обычным абстрактным методом, а другой - методом по умолчанию. Обратите внимание,
что оба метода предполагаются publicкак все методы интерфейса public. Первый метод завершается точкой с запятой и не предоставляет тело,
тогда как второй метод по умолчанию предоставляет тело. Любой реализующий класс IsWarmBloodedможет полагаться на реализацию по умолчанию getTemperature()или
переопределять метод и создавать свою собственную версию.
Обратите внимание, что модификатор доступа по умолчанию, определенный в главе 4, полностью отличается от метода по умолчанию, определенного в этой главе.
Мы определили модификатор доступа по умолчанию в главе 4 как отсутствие модификатора доступа, который указал, что класс может обращаться к классу,
методу или значению в другом классе, если оба класса находятся в одном пакете. В этой главе мы конкретно говорим о ключевом слове defaultприменительно к методу в интерфейсе.
Поскольку предполагается, что все методы в интерфейсе являются publicмодификаторами доступа для метода по умолчанию public.
Ниже приведены правила метода интерфейса по умолчанию, с которыми вам необходимо ознакомиться:
1.	Метод по умолчанию может быть объявлен только внутри интерфейса, а не внутри класса или абстрактного класса.
2.	Метод по умолчанию должен быть помечен defaultключевым словом. Если метод помечен как default, он должен предоставить тело метода.
3.	Метод по умолчанию не предполагается static, finalили abstract, как он может быть использован или переопределен классом, который реализует интерфейс.
4.	подобно все методы в интерфейсе, метод по умолчанию считается publicи не будет компилироваться, если помечен как privateили protected.
Первое правило должно дать вам некоторое утешение в том, что вы будете видеть только методы по умолчанию в интерфейсах. Если вы видите их в классе на экзамене,
предположите, что код не будет компилироваться. Второе правило просто обозначает синтаксис, поскольку методы по умолчанию должны использовать defaultключевое слово.
Например, следующие фрагменты кода не будут компилироваться:
public interface Carnivore { 
 public default void eatMeat();  // DOES NOT COMPILE
  public int getRequiredFoodAmount() {  // DOES NOT COMPILE 
   return 13; 
 }}
В этом примере первый метод eatMeat()не компилируется, потому что он помечен как, defaultно не предоставляет тело метода.
Второй метод, getRequiredFoodAmount()также не компилируется, потому что он предоставляет тело метода, но не помечен defaultключевым словом.
В отличие от переменных интерфейса, которые предполагаются staticчленами класса, методы по умолчанию не могут быть помечены как staticи требуют, 
чтобы экземпляр класса, реализующий интерфейс, вызывался. Они также не могут быть помечены как finalили abstract, потому что они могут быть переопределены в подклассах, 
но не должны быть переопределены.
Когда интерфейс extendsдругой интерфейс, который содержит метод по умолчанию, он может выбрать игнорировать метод по умолчанию,
и в этом случае будет использоваться реализация по умолчанию для метода. В качестве альтернативы интерфейс может переопределить определение метода по умолчанию,
используя стандартные правила для переопределения метода, например, не ограничивая доступность метода и используя ковариантные возвраты. Наконец,
интерфейс может переопределить метод как абстрактный, требуя, чтобы классы, реализующие новый интерфейс, явно предоставили тело метода.
Аналогичные параметры применяются к абстрактному классу, который implementsявляется интерфейсом.
Например, следующий класс переопределяет один метод интерфейса по умолчанию и повторно объявляет второй метод интерфейса следующим образом abstract:

public interface HasFins {
  public default int getNumberOfFins() {  
  return 4; 
 }  
public default double getLongestFinLength() {
    return 20.0;
  }  
public default boolean doFinsHaveScales() { 
   return true;  
}}
public interface SharkFamily extends HasFins { 
 public default int getNumberOfFins() {  
  return 8; 
 }
  public double getLongestFinLength(); 
 public boolean doFinsHaveScales() {
  // DOES NOT COMPILE  
  return false;  
}}
В данном примере, первый интерфейс, HasFinsопределяет три метода: по умолчанию getNumberOfFins(), getLongestFinLength()и doFinsHaveScales(). Второй интерфейс, SharkFamilyрасширяет HasFinsи переопределяет метод по умолчанию getNumberOfFins()новым методом, который возвращает другое значение. Затем SharkFamilyинтерфейс заменяет метод по умолчанию getLongestFinLength()новым абстрактным методом, заставляя любой класс, реализующий SharkFamilyинтерфейс, предоставить реализацию метода. Наконец, SharkFamilyинтерфейс переопределяет doFinsHaveScales()метод, но не помечает метод как default. Поскольку интерфейсы могут содержать только методы с телом, помеченным как default, код не будет компилироваться.
Поскольку методы по умолчанию являются новыми для Java 8, вероятно, на экзамене будет несколько вопросов о них, хотя они, вероятно, не будут более сложными,
чем в предыдущем примере.

Методы по умолчанию и множественное наследование


Возможно, вы поняли, что, разрешив методы по умолчанию в интерфейсах, в сочетании с тем фактом, что класс может реализовывать несколько интерфейсов,
Java по существу открыла дверь к множественным проблемам наследования. Например, какое значение выдает следующий код?

public interface Walk { 
 public default int getSpeed() {  
  return 5; 
 }}
public interface Run { 
 public default int getSpeed() { 
   return 10; 
 }}
public class Cat implements Walk, Run {  // DOES NOT COMPILE
  public static void main(String[] args) {
    System.out.println(new Cat().getSpeed());
  }}
В этом примере Catнаследует два метода по умолчанию для getSpeed(), так что он использует? Так как Walkи Runсчитаются родными братьями с точки зрения того, 
как они используются в Catклассе, не ясно, должен ли код выводить 5или 10. Ответ в том, что код не выводит ни одно значение - он не компилируется.
Если класс реализует два интерфейса, которые имеют методы по умолчанию с одинаковыми именем и сигнатурой, компилятор выдаст ошибку.
Однако из этого правила есть исключение: если подкласс переопределяет дубликаты методов по умолчанию,
код будет компилироваться без проблем - неоднозначность того, какая версия вызываемого метода была удалена.
Например, следующая измененная реализация Catскомпилирует и выведет 1:

public class Cat implements Walk, Run { 
 public int getSpeed() {    
return 1;
  }
  public static void main(String[] args) {  
  System.out.println(new Cat().getSpeed()); 
 }}
Вы можете видеть, что наличие класса, который реализует или наследует два дублирующих метода по умолчанию, вынуждает класс реализовать новую версию метода,
иначе код не будет компилироваться. Это правило сохраняется даже для абстрактных классов, которые реализуют несколько интерфейсов,
потому что метод по умолчанию может быть вызван в конкретном методе внутри абстрактного класса.

Методы статического интерфейса


Java 8 также теперь включает поддержку статических методов в интерфейсах. Эти методы определены явно с помощью staticключевого слова и функционируют почти так же,
как статические методы, определенные в классах, как обсуждалось в главе 4. На самом деле, существует только одно различие между статическим методом в классе и интерфейсом.
Статический метод, определенный в интерфейсе, не наследуется ни в каких классах, которые реализуют интерфейс.
Вот правила статического метода интерфейса, с которыми вам нужно ознакомиться:
1.	Как и все методы в интерфейсе, предполагается, что статический метод является publicи не будет компилироваться, если помечен как privateили protected.
2.	Для ссылки на статический метод необходимо использовать ссылку на имя интерфейса.
Ниже приведен пример статического метода, определенного в интерфейсе:
public interface Hop { 
 static int getJumpHeight() { 
   return 8;  
}}
Метод getJumpHeight()работает так же, как статический метод, определенный в классе. Другими словами,
к нему можно получить доступ без экземпляра класса с использованием Hop.getJumpHeight()синтаксиса.
Также обратите внимание, что компилятор автоматически вставит модификатор доступа, publicпоскольку предполагается, что все методы в интерфейсах public.
Ниже приведен пример класса, Bunnyкоторый реализует Hop:

public class Bunny implements Hop {
  public void printDetails() {   
 System.out.println(getJumpHeight()); // DOES NOT COMPILE
  }}
Как видите, без явной ссылки на имя интерфейса код не скомпилируется, хотя и Bunnyреализуется Hop. Таким образом, методы статического интерфейса не наследуются классом,
реализующим интерфейс. Следующая измененная версия кода решает проблему со ссылкой на имя интерфейса Hop:

public class Bunny implements Hop { 
 public void printDetails() {
    System.out.println(Hop.getJumpHeight()); 
 }}
Из этого следует, что класс, который реализует два интерфейса, содержащие статические методы с одной и той же сигнатурой, все еще будет компилироваться во время выполнения,
поскольку статические методы не наследуются подклассом и должны быть доступны со ссылкой на имя интерфейса. Сравните это с поведением, 
которое вы видели для методов интерфейса по умолчанию в предыдущем разделе: код скомпилировался бы, если бы подкласс переопределил методы по умолчанию
и не скомпилировал бы иначе. Вы можете видеть, что у статических методов интерфейса нет ни одной из тех же проблем и правил множественного наследования,
что и у методов интерфейса по умолчанию.

